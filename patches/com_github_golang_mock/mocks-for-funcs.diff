diff --git mockgen/model/model.go mockgen/model/model.go
index 2c6a62c..18106ce 100644
--- mockgen/model/model.go
+++ mockgen/model/model.go
@@ -299,28 +299,44 @@ func (pt PredeclaredType) addImports(map[string]bool)              {}
 
 // The following code is intended to be called by the program generated by ../reflect.go.
 
-// InterfaceFromInterfaceType returns a pointer to an interface for the
-// given reflection interface type.
-func InterfaceFromInterfaceType(it reflect.Type) (*Interface, error) {
-	if it.Kind() != reflect.Interface {
-		return nil, fmt.Errorf("%v is not an interface", it)
-	}
+// InterfaceFromInterfaceOrFuncType returns a pointer to an interface for the
+// given reflection interface or function type.
+func InterfaceFromInterfaceOrFuncType(it reflect.Type) (*Interface, error) {
 	intf := &Interface{}
 
-	for i := 0; i < it.NumMethod(); i++ {
-		mt := it.Method(i)
-		// TODO: need to skip unexported methods? or just raise an error?
+	switch it.Kind() {
+	case reflect.Interface:
+		for i := 0; i < it.NumMethod(); i++ {
+			mt := it.Method(i)
+			// TODO: need to skip unexported methods? or just raise an error?
+			m := &Method{
+				Name: mt.Name,
+			}
+
+			var err error
+			m.In, m.Variadic, m.Out, err = funcArgsFromType(mt.Type)
+			if err != nil {
+				return nil, err
+			}
+
+			intf.AddMethod(m)
+		}
+	case reflect.Func:
+		// For function types, generate an interface having a single
+		// "Call" method.
 		m := &Method{
-			Name: mt.Name,
+			Name: "Call",
 		}
 
 		var err error
-		m.In, m.Variadic, m.Out, err = funcArgsFromType(mt.Type)
+		m.In, m.Variadic, m.Out, err = funcArgsFromType(it)
 		if err != nil {
 			return nil, err
 		}
 
 		intf.AddMethod(m)
+	default:
+		return nil, fmt.Errorf("%v is not an interface or function type", it)
 	}
 
 	return intf, nil
diff --git mockgen/parse.go mockgen/parse.go
index bf6902c..e5d37b3 100644
--- mockgen/parse.go
+++ mockgen/parse.go
@@ -171,7 +171,7 @@ func (p *fileParser) addAuxInterfacesFromFile(pkg string, file *ast.File) {
 	if _, ok := p.auxInterfaces[pkg]; !ok {
 		p.auxInterfaces[pkg] = make(map[string]*ast.InterfaceType)
 	}
-	for ni := range iterInterfaces(file) {
+	for _, ni := range extractInterfaces(file) {
 		p.auxInterfaces[pkg][ni.name.Name] = ni.it
 	}
 }
@@ -198,8 +198,22 @@ func (p *fileParser) parseFile(importPath string, file *ast.File) (*model.Packag
 	}
 
 	var is []*model.Interface
-	for ni := range iterInterfaces(file) {
-		i, err := p.parseInterface(ni.name.String(), importPath, ni.it)
+	for _, ni := range extractInterfaces(file) {
+		i, err := p.parseInterface(ni.name.String(), importPath, ni.it.Methods.List)
+		if err != nil {
+			return nil, err
+		}
+		is = append(is, i)
+	}
+	for _, ni := range extractFuncs(file) {
+		// For function types, generate an interface having a single
+		// "Call" method.
+		i, err := p.parseInterface(ni.name.String(), importPath, []*ast.Field{
+			{
+				Names: []*ast.Ident{{Name: "Call"}},
+				Type:  ni.ft,
+			},
+		})
 		if err != nil {
 			return nil, err
 		}
@@ -236,7 +250,7 @@ func (p *fileParser) parsePackage(path string) (*fileParser, error) {
 		if _, ok := newP.importedInterfaces[path]; !ok {
 			newP.importedInterfaces[path] = make(map[string]*ast.InterfaceType)
 		}
-		for ni := range iterInterfaces(file) {
+		for _, ni := range extractInterfaces(file) {
 			newP.importedInterfaces[path][ni.name.Name] = ni.it
 		}
 		imports, _ := importsOfFile(file)
@@ -247,9 +261,9 @@ func (p *fileParser) parsePackage(path string) (*fileParser, error) {
 	return newP, nil
 }
 
-func (p *fileParser) parseInterface(name, pkg string, it *ast.InterfaceType) (*model.Interface, error) {
+func (p *fileParser) parseInterface(name, pkg string, fields []*ast.Field) (*model.Interface, error) {
 	iface := &model.Interface{Name: name}
-	for _, field := range it.Methods.List {
+	for _, field := range fields {
 		switch v := field.Type.(type) {
 		case *ast.FuncType:
 			if nn := len(field.Names); nn != 1 {
@@ -274,7 +288,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *ast.InterfaceType) (*m
 			var embeddedIface *model.Interface
 			if embeddedIfaceType != nil {
 				var err error
-				embeddedIface, err = p.parseInterface(v.String(), pkg, embeddedIfaceType)
+				embeddedIface, err = p.parseInterface(v.String(), pkg, embeddedIfaceType.Methods.List)
 				if err != nil {
 					return nil, err
 				}
@@ -302,7 +316,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *ast.InterfaceType) (*m
 			var err error
 			embeddedIfaceType := p.auxInterfaces[filePkg][sel]
 			if embeddedIfaceType != nil {
-				embeddedIface, err = p.parseInterface(sel, filePkg, embeddedIfaceType)
+				embeddedIface, err = p.parseInterface(sel, filePkg, embeddedIfaceType.Methods.List)
 				if err != nil {
 					return nil, err
 				}
@@ -323,7 +337,7 @@ func (p *fileParser) parseInterface(name, pkg string, it *ast.InterfaceType) (*m
 				if embeddedIfaceType = parser.importedInterfaces[path][sel]; embeddedIfaceType == nil {
 					return nil, p.errorf(v.Pos(), "unknown embedded interface %s.%s", path, sel)
 				}
-				embeddedIface, err = parser.parseInterface(sel, path, embeddedIfaceType)
+				embeddedIface, err = parser.parseInterface(sel, path, embeddedIfaceType.Methods.List)
 				if err != nil {
 					return nil, err
 				}
@@ -579,32 +593,54 @@ type namedInterface struct {
 	it   *ast.InterfaceType
 }
 
-// Create an iterator over all interfaces in file.
-func iterInterfaces(file *ast.File) <-chan namedInterface {
-	ch := make(chan namedInterface)
-	go func() {
-		for _, decl := range file.Decls {
-			gd, ok := decl.(*ast.GenDecl)
-			if !ok || gd.Tok != token.TYPE {
+// Extracts all interfaces from a file.
+func extractInterfaces(file *ast.File) (interfaces []namedInterface) {
+	for _, decl := range file.Decls {
+		gd, ok := decl.(*ast.GenDecl)
+		if !ok || gd.Tok != token.TYPE {
+			continue
+		}
+		for _, spec := range gd.Specs {
+			ts, ok := spec.(*ast.TypeSpec)
+			if !ok {
+					continue
+			}
+			it, ok := ts.Type.(*ast.InterfaceType)
+			if !ok {
 				continue
 			}
-			for _, spec := range gd.Specs {
-				ts, ok := spec.(*ast.TypeSpec)
-				if !ok {
-					continue
-				}
-				it, ok := ts.Type.(*ast.InterfaceType)
-				if !ok {
-					continue
-				}
+			interfaces = append(interfaces, namedInterface{ts.Name, it})
+		}
+	}
+	return
+}
+
+type namedFunc struct {
+	name *ast.Ident
+	ft   *ast.FuncType
+}
 
-				ch <- namedInterface{ts.Name, it}
+// Extracts all function types from a file.
+func extractFuncs(file *ast.File) (funcs []namedFunc) {
+	for _, decl := range file.Decls {
+		gd, ok := decl.(*ast.GenDecl)
+		if !ok || gd.Tok != token.TYPE {
+			continue
+		}
+		for _, spec := range gd.Specs {
+			ts, ok := spec.(*ast.TypeSpec)
+			if !ok {
+				continue
+ 			}
+			ft, ok := ts.Type.(*ast.FuncType)
+			if !ok {
+				continue
 			}
+			funcs = append(funcs, namedFunc{ts.Name, ft})
 		}
-		close(ch)
-	}()
-	return ch
-}
+	}
+	return
+ }
 
 // isVariadic returns whether the function is variadic.
 func isVariadic(f *ast.FuncType) bool {
diff --git mockgen/reflect.go mockgen/reflect.go
index e24efce..48a6407 100644
--- mockgen/reflect.go
+++ mockgen/reflect.go
@@ -224,7 +224,7 @@ func main() {
 	}
 
 	for _, it := range its {
-		intf, err := model.InterfaceFromInterfaceType(it.typ)
+		intf, err := model.InterfaceFromInterfaceOrFuncType(it.typ)
 		if err != nil {
 			fmt.Fprintf(os.Stderr, "Reflection: %v\n", err)
 			os.Exit(1)
