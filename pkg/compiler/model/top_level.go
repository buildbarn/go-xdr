package model

import (
	"fmt"
	"io"
	"path"
	"sort"
)

// TopLevel contains all of the information declared in an XDR schema
// file. As an extension, this implementation requires that all schema
// files contain a package name and import directives.
type TopLevel struct {
	pkg         string
	imports     []string
	definitions []Definition
}

// NewTopLevel constructs a TopLevel based on parsed definitions.
func NewTopLevel(pkg string, imports []string, definitions []Definition) TopLevel {
	return TopLevel{
		pkg:         pkg,
		imports:     imports,
		definitions: definitions,
	}
}

// Emit an XDR schema file as Go code.
func (tl TopLevel) Emit(w io.StringWriter, r Resolver) error {
	if _, err := w.WriteString(fmt.Sprintf("// Code generated by go-xdr. DO NOT EDIT.\npackage %s\n", path.Base(tl.pkg))); err != nil {
		return err
	}

	importCapturingSink := importCapturingSink{
		imports: map[string]struct{}{},
		pkg:     tl.pkg,
	}
	for _, definition := range tl.definitions {
		if err := definition.emitAllDefinitions(&importCapturingSink, r); err != nil {
			return err
		}
	}

	if imports := importCapturingSink.imports; len(imports) > 0 {
		importURLs := make([]string, 0, len(imports))
		for importURL := range imports {
			importURLs = append(importURLs, importURL)
		}
		sort.Strings(importURLs)

		if _, err := w.WriteString("\nimport (\n"); err != nil {
			return err
		}
		for _, importURL := range importURLs {
			if _, err := w.WriteString(fmt.Sprintf("%#v\n", importURL)); err != nil {
				return err
			}
		}
		if _, err := w.WriteString(")\n"); err != nil {
			return err
		}
	}

	writingSink := writingSink{
		pkg: tl.pkg,
		w:   w,
	}
	for _, definition := range tl.definitions {
		if err := definition.emitAllDefinitions(&writingSink, r); err != nil {
			return err
		}
	}
	return writingSink.err
}

// Register all imports and definitions in an XDR schema file into a
// Registry, so that definitions in multiple XDR schema files can be
// tied together.
func (tl TopLevel) Register(r Registry) error {
	for _, path := range tl.imports {
		if err := r.RegisterImport(path); err != nil {
			return err
		}
	}
	for _, definition := range tl.definitions {
		if err := definition.register(r, tl.pkg); err != nil {
			return err
		}
	}
	return nil
}

type importCapturingSink struct {
	imports map[string]struct{}
	pkg     string
}

func (s *importCapturingSink) emitString(v string) {}

func (s *importCapturingSink) emitPackageNamePrefix(pkg string) {
	if pkg != s.pkg {
		s.imports[pkg] = struct{}{}
	}
}

type writingSink struct {
	pkg string
	w   io.StringWriter
	err error
}

func (s *writingSink) emitString(v string) {
	if s.err == nil {
		_, s.err = s.w.WriteString(v)
	}
}

func (s *writingSink) emitPackageNamePrefix(pkg string) {
	if pkg != s.pkg {
		s.emitString(path.Base(pkg))
		s.emitString(".")
	}
}
