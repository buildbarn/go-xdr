// Code generated by go-xdr. DO NOT EDIT.
package nested

import (
	"fmt"
	"io"

	"github.com/buildbarn/go-xdr/pkg/runtime"
)

// Type definition "a".

type A struct {
	B struct {
		C struct {
			D aBCD
			E interface {
				isABCE()
				GetI() aBCEI
				io.WriterTo
			}
		}
	}
}

func (m *A) ReadFrom(r io.Reader) (nTotal int64, err error) {
	var nField int64
	{
		m := &m.B
		{
			m := &m.C
			{
				mSave := &m.D
				var m aBCD
				*(*int32)(&m), nField, err = runtime.ReadInt(r)
				nTotal += nField
				if err != nil {
					goto done
				}
				*mSave = m
			}
			{
				mSave := &m.E
				var m interface {
					isABCE()
					GetI() aBCEI
					io.WriterTo
				}
				var discriminant aBCEI
				{
					var m aBCEI
					*(*int32)(&m), nField, err = runtime.ReadInt(r)
					nTotal += nField
					if err != nil {
						goto done
					}
					discriminant = m
				}
				switch discriminant {
				case 3:
					var mArm ABCE_ABRA
					{
						m := &mArm
						{
							mSave := &m.J
							var m aBCEJ
							*(*int32)(&m), nField, err = runtime.ReadInt(r)
							nTotal += nField
							if err != nil {
								goto done
							}
							*mSave = m
						}
					}
					m = &mArm
				case 4:
					var mArm ABCE_CADABRA
					{
						m := &mArm
						{
							m := &m.K
							{
								mSave := &m.L
								var m int32
								m, nField, err = runtime.ReadInt(r)
								nTotal += nField
								if err != nil {
									goto done
								}
								*mSave = m
							}
						}
					}
					m = &mArm
				default:
					err = fmt.Errorf("discriminant a.b.c.e.i has unknown value %d", discriminant)
					goto done
				}
				*mSave = m
			}
		}
	}
done:
	return
}

func (m *A) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		m := &m.B
		{
			m := &m.C
			{
				m := m.D
				nField, err = runtime.WriteInt(w, int32(m))
				nTotal += nField
				if err != nil {
					goto done
				}
			}
			{
				m := m.E
				nField, err = m.WriteTo(w)
				nTotal += nField
				if err != nil {
					goto done
				}
			}
		}
	}
done:
	return
}

const AEncodedSizeBytes = 12

type aBCD int32

const BAR aBCD = 2

const FOO aBCD = 1

var aBCD_name = map[aBCD]string{
	2: "BAR",
	1: "FOO",
}

type aBCEI int32

func (mParent *aBCEI) ReadFrom(r io.Reader) (nTotal int64, err error) {
	var nField int64
	var m aBCEI
	*(*int32)(&m), nField, err = runtime.ReadInt(r)
	nTotal += nField
	if err != nil {
		goto done
	}
	*mParent = m
done:
	return
}

func (m aBCEI) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	nField, err = runtime.WriteInt(w, int32(m))
	nTotal += nField
	if err != nil {
		goto done
	}
done:
	return
}

const aBCEIEncodedSizeBytes = 4

const ABRA aBCEI = 3

const CADABRA aBCEI = 4

var aBCEI_name = map[aBCEI]string{
	3: "ABRA",
	4: "CADABRA",
}

type aBCEJ int32

const BOAT aBCEJ = 2

const CAR aBCEJ = 1

var aBCEJ_name = map[aBCEJ]string{
	2: "BOAT",
	1: "CAR",
}

type ABCE_ABRA struct {
	J aBCEJ
}

func (m *ABCE_ABRA) isABCE() {}

func (m *ABCE_ABRA) GetI() aBCEI {
	return 3
}

func (m *ABCE_ABRA) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		var m aBCEI = 3
		nField, err = runtime.WriteInt(w, int32(m))
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := m.J
		nField, err = runtime.WriteInt(w, int32(m))
		nTotal += nField
		if err != nil {
			goto done
		}
	}
done:
	return
}

type ABCE_CADABRA struct {
	K struct {
		L int32
	}
}

func (m *ABCE_CADABRA) isABCE() {}

func (m *ABCE_CADABRA) GetI() aBCEI {
	return 4
}

func (m *ABCE_CADABRA) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		var m aBCEI = 4
		nField, err = runtime.WriteInt(w, int32(m))
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := &m.K
		{
			m := m.L
			nField, err = runtime.WriteInt(w, m)
			nTotal += nField
			if err != nil {
				goto done
			}
		}
	}
done:
	return
}

// Type definition "pointer_to_enum".

type PointerToEnum = *pointerToEnumImpl

func ReadPointerToEnum(r io.Reader) (m *pointerToEnumImpl, nTotal int64, err error) {
	var nField int64
	var isSet bool
	isSet, nField, err = runtime.ReadBool(r)
	nTotal += nField
	if err != nil {
		goto done
	}
	if isSet {
		mParent := &m
		var m pointerToEnumImpl
		*(*int32)(&m), nField, err = runtime.ReadInt(r)
		nTotal += nField
		if err != nil {
			goto done
		}
		*mParent = &m
	}
done:
	return
}

func WritePointerToEnum(w io.Writer, m *pointerToEnumImpl) (nTotal int64, err error) {
	var nField int64
	if m == nil {
		nField, err = runtime.WriteBool(w, false)
		nTotal += nField
		if err != nil {
			goto done
		}
	} else {
		nField, err = runtime.WriteBool(w, true)
		nTotal += nField
		if err != nil {
			goto done
		}
		{
			m := *m
			nField, err = runtime.WriteInt(w, int32(m))
			nTotal += nField
			if err != nil {
				goto done
			}
		}
	}
done:
	return
}

func GetPointerToEnumEncodedSizeBytes(m *pointerToEnumImpl) (nTotal int) {
	nTotal += 4
	if m != nil {
		nTotal += 4
	}
	return
}

type pointerToEnumImpl int32

const CAT pointerToEnumImpl = 1

const DOG pointerToEnumImpl = 0

var pointerToEnumImpl_name = map[pointerToEnumImpl]string{
	1: "CAT",
	0: "DOG",
}
