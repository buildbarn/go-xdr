// Code generated by go-xdr. DO NOT EDIT.
package rfc4506

import (
	"fmt"
	"io"

	"github.com/buildbarn/go-xdr/pkg/runtime"
)

const DOZEN = 12

// Type definition "egg".

type Egg = int32

func ReadEgg(r io.Reader) (m int32, nTotal int64, err error) {
	var nField int64
	m, nField, err = runtime.ReadInt(r)
	nTotal += nField
	if err != nil {
		goto done
	}
done:
	return
}

func WriteEgg(w io.Writer, m int32) (nTotal int64, err error) {
	var nField int64
	nField, err = runtime.WriteInt(w, m)
	nTotal += nField
	if err != nil {
		goto done
	}
done:
	return
}

const EggEncodedSizeBytes = 4

// Type definition "eggbox".

type Eggbox = [12]int32

func ReadEggbox(r io.Reader, m *[12]int32) (nTotal int64, err error) {
	var nField int64
	mParent := m
	for i := 0; i < len(m); i++ {
		var m int32
		m, nField, err = runtime.ReadInt(r)
		nTotal += nField
		if err != nil {
			goto done
		}
		mParent[i] = m
	}
done:
	return
}

func WriteEggbox(w io.Writer, m *[12]int32) (nTotal int64, err error) {
	var nField int64
	for _, m := range m {
		nField, err = runtime.WriteInt(w, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
done:
	return
}

const EggboxEncodedSizeBytes = 48

// Type definition "eggs".

type Eggs struct {
	Fresheggs1 [12]int32
	Fresheggs2 [12]int32
}

func (m *Eggs) ReadFrom(r io.Reader) (nTotal int64, err error) {
	var nField int64
	{
		m := &m.Fresheggs1
		nField, err = ReadEggbox(r, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := &m.Fresheggs2
		mParent := m
		for i := 0; i < len(m); i++ {
			var m int32
			m, nField, err = runtime.ReadInt(r)
			nTotal += nField
			if err != nil {
				goto done
			}
			mParent[i] = m
		}
	}
done:
	return
}

func (m *Eggs) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		m := &m.Fresheggs1
		nField, err = WriteEggbox(w, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := &m.Fresheggs2
		for _, m := range m {
			nField, err = runtime.WriteInt(w, m)
			nTotal += nField
			if err != nil {
				goto done
			}
		}
	}
done:
	return
}

const EggsEncodedSizeBytes = 96

// Type definition "stringentry1".

type Stringentry1 struct {
	Item string
	Next *Stringentry1
}

func (m *Stringentry1) ReadFrom(r io.Reader) (nTotal int64, err error) {
	var nField int64
	{
		mSave := &m.Item
		var m string
		m, nField, err = runtime.ReadASCIIString(r, 4294967295)
		nTotal += nField
		if err != nil {
			goto done
		}
		*mSave = m
	}
	{
		mSave := &m.Next
		var m *Stringentry1
		var isSet bool
		isSet, nField, err = runtime.ReadBool(r)
		nTotal += nField
		if err != nil {
			goto done
		}
		if isSet {
			mParent := &m
			var m Stringentry1
			nField, err = m.ReadFrom(r)
			nTotal += nField
			if err != nil {
				goto done
			}
			*mParent = &m
		}
		*mSave = m
	}
done:
	return
}

func (m *Stringentry1) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		m := m.Item
		nField, err = runtime.WriteASCIIString(w, 4294967295, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := m.Next
		if m == nil {
			nField, err = runtime.WriteBool(w, false)
			nTotal += nField
			if err != nil {
				goto done
			}
		} else {
			nField, err = runtime.WriteBool(w, true)
			nTotal += nField
			if err != nil {
				goto done
			}
			{
				nField, err = m.WriteTo(w)
				nTotal += nField
				if err != nil {
					goto done
				}
			}
		}
	}
done:
	return
}

func (m *Stringentry1) GetEncodedSizeBytes() (nTotal int) {
	{
		m := m.Item
		nTotal += (len(m) + 7) &^ 3
	}
	{
		m := m.Next
		nTotal += 4
		if m != nil {
			nTotal += m.GetEncodedSizeBytes()
		}
	}
	return
}

// Type definition "stringlist1".

type Stringlist1 = *Stringentry1

func ReadStringlist1(r io.Reader) (m *Stringentry1, nTotal int64, err error) {
	var nField int64
	var isSet bool
	isSet, nField, err = runtime.ReadBool(r)
	nTotal += nField
	if err != nil {
		goto done
	}
	if isSet {
		mParent := &m
		var m Stringentry1
		nField, err = m.ReadFrom(r)
		nTotal += nField
		if err != nil {
			goto done
		}
		*mParent = &m
	}
done:
	return
}

func WriteStringlist1(w io.Writer, m *Stringentry1) (nTotal int64, err error) {
	var nField int64
	if m == nil {
		nField, err = runtime.WriteBool(w, false)
		nTotal += nField
		if err != nil {
			goto done
		}
	} else {
		nField, err = runtime.WriteBool(w, true)
		nTotal += nField
		if err != nil {
			goto done
		}
		{
			nField, err = m.WriteTo(w)
			nTotal += nField
			if err != nil {
				goto done
			}
		}
	}
done:
	return
}

func GetStringlist1EncodedSizeBytes(m *Stringentry1) (nTotal int) {
	nTotal += 4
	if m != nil {
		nTotal += m.GetEncodedSizeBytes()
	}
	return
}

// Type definition "stringlist2".

type Stringlist2 interface {
	isStringlist2()
	GetOpted() bool
	io.WriterTo
	GetEncodedSizeBytes() int
}

func ReadStringlist2(r io.Reader) (m Stringlist2, nTotal int64, err error) {
	var nField int64
	var discriminant bool
	{
		var m bool
		m, nField, err = runtime.ReadBool(r)
		nTotal += nField
		if err != nil {
			goto done
		}
		discriminant = m
	}
	switch discriminant {
	case true:
		var mArm Stringlist2_TRUE
		{
			m := &mArm
			{
				m := &m.Element
				{
					mSave := &m.Item
					var m string
					m, nField, err = runtime.ReadASCIIString(r, 4294967295)
					nTotal += nField
					if err != nil {
						goto done
					}
					*mSave = m
				}
				{
					mSave := &m.Next
					var m Stringlist2
					m, nField, err = ReadStringlist2(r)
					nTotal += nField
					if err != nil {
						goto done
					}
					*mSave = m
				}
			}
		}
		m = &mArm
	case false:
		var mArm Stringlist2_FALSE
		{
			m := &mArm
			_ = m
		}
		m = &mArm
	default:
		err = fmt.Errorf("discriminant stringlist2.opted has unknown value %d", discriminant)
		goto done
	}
done:
	return
}

func readStringlist2Opted(r io.Reader) (m bool, nTotal int64, err error) {
	var nField int64
	m, nField, err = runtime.ReadBool(r)
	nTotal += nField
	if err != nil {
		goto done
	}
done:
	return
}

func writeStringlist2Opted(w io.Writer, m bool) (nTotal int64, err error) {
	var nField int64
	nField, err = runtime.WriteBool(w, m)
	nTotal += nField
	if err != nil {
		goto done
	}
done:
	return
}

const stringlist2OptedEncodedSizeBytes = 4

type Stringlist2_TRUE struct {
	Element struct {
		Item string
		Next Stringlist2
	}
}

func (m *Stringlist2_TRUE) isStringlist2() {}

func (m *Stringlist2_TRUE) GetOpted() bool {
	return true
}

func (m *Stringlist2_TRUE) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		var m bool = true
		nField, err = runtime.WriteBool(w, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := &m.Element
		{
			m := m.Item
			nField, err = runtime.WriteASCIIString(w, 4294967295, m)
			nTotal += nField
			if err != nil {
				goto done
			}
		}
		{
			m := m.Next
			nField, err = m.WriteTo(w)
			nTotal += nField
			if err != nil {
				goto done
			}
		}
	}
done:
	return
}

func (m *Stringlist2_TRUE) GetEncodedSizeBytes() (nTotal int) {
	nTotal += 4
	{
		m := &m.Element
		{
			m := m.Item
			nTotal += (len(m) + 7) &^ 3
		}
		{
			m := m.Next
			nTotal += m.GetEncodedSizeBytes()
		}
	}
	return
}

type Stringlist2_FALSE struct{}

func (m *Stringlist2_FALSE) isStringlist2() {}

func (m *Stringlist2_FALSE) GetOpted() bool {
	return false
}

func (m *Stringlist2_FALSE) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		var m bool = false
		nField, err = runtime.WriteBool(w, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
done:
	return
}

func (m *Stringlist2_FALSE) GetEncodedSizeBytes() (nTotal int) {
	nTotal += 4
	return
}

// Type definition "stringentry3".

type Stringentry3 struct {
	Item string
	Next []Stringentry3
}

func (m *Stringentry3) ReadFrom(r io.Reader) (nTotal int64, err error) {
	var nField int64
	{
		mSave := &m.Item
		var m string
		m, nField, err = runtime.ReadASCIIString(r, 4294967295)
		nTotal += nField
		if err != nil {
			goto done
		}
		*mSave = m
	}
	{
		mSave := &m.Next
		var m []Stringentry3
		var nElements uint32
		nElements, nField, err = runtime.ReadUnsignedInt(r)
		nTotal += nField
		if err != nil {
			goto done
		}
		if nElements > 1 {
			err = fmt.Errorf("size of %d elements exceeds stringentry3.next's maximum of 1 elements", nElements)
			goto done
		}
		for nElements > 0 {
			nElements--
			m = append(m, Stringentry3{})
			m := &m[len(m)-1]
			nField, err = m.ReadFrom(r)
			nTotal += nField
			if err != nil {
				goto done
			}
		}
		*mSave = m
	}
done:
	return
}

func (m *Stringentry3) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		m := m.Item
		nField, err = runtime.WriteASCIIString(w, 4294967295, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := m.Next
		if len(m) > 1 {
			err = fmt.Errorf("size of %d elements exceeds stringentry3.next's maximum of 1 elements", len(m))
			goto done
		}
		nField, err = runtime.WriteUnsignedInt(w, uint32(len(m)))
		nTotal += nField
		if err != nil {
			goto done
		}
		for _, m := range m {
			nField, err = m.WriteTo(w)
			nTotal += nField
			if err != nil {
				goto done
			}
		}
	}
done:
	return
}

func (m *Stringentry3) GetEncodedSizeBytes() (nTotal int) {
	{
		m := m.Item
		nTotal += (len(m) + 7) &^ 3
	}
	{
		m := m.Next
		nTotal += 4
		for _, m := range m {
			nTotal += m.GetEncodedSizeBytes()
		}
	}
	return
}

// Type definition "stringlist3".

type Stringlist3 = []Stringentry3

func ReadStringlist3(r io.Reader) (m []Stringentry3, nTotal int64, err error) {
	var nField int64
	var nElements uint32
	nElements, nField, err = runtime.ReadUnsignedInt(r)
	nTotal += nField
	if err != nil {
		goto done
	}
	if nElements > 1 {
		err = fmt.Errorf("size of %d elements exceeds stringlist3's maximum of 1 elements", nElements)
		goto done
	}
	for nElements > 0 {
		nElements--
		m = append(m, Stringentry3{})
		m := &m[len(m)-1]
		nField, err = m.ReadFrom(r)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
done:
	return
}

func WriteStringlist3(w io.Writer, m []Stringentry3) (nTotal int64, err error) {
	var nField int64
	if len(m) > 1 {
		err = fmt.Errorf("size of %d elements exceeds stringlist3's maximum of 1 elements", len(m))
		goto done
	}
	nField, err = runtime.WriteUnsignedInt(w, uint32(len(m)))
	nTotal += nField
	if err != nil {
		goto done
	}
	for _, m := range m {
		nField, err = m.WriteTo(w)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
done:
	return
}

func GetStringlist3EncodedSizeBytes(m []Stringentry3) (nTotal int) {
	nTotal += 4
	for _, m := range m {
		nTotal += m.GetEncodedSizeBytes()
	}
	return
}

const MAXUSERNAME = 32

const MAXFILELEN = 65535

const MAXNAMELEN = 255

// Type definition "filekind".

type Filekind int32

func (mParent *Filekind) ReadFrom(r io.Reader) (nTotal int64, err error) {
	var nField int64
	var m Filekind
	*(*int32)(&m), nField, err = runtime.ReadInt(r)
	nTotal += nField
	if err != nil {
		goto done
	}
	*mParent = m
done:
	return
}

func (m Filekind) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	nField, err = runtime.WriteInt(w, int32(m))
	nTotal += nField
	if err != nil {
		goto done
	}
done:
	return
}

const FilekindEncodedSizeBytes = 4

const DATA Filekind = 1

const EXEC Filekind = 2

const TEXT Filekind = 0

var Filekind_name = map[Filekind]string{
	1: "DATA",
	2: "EXEC",
	0: "TEXT",
}

// Type definition "filetype".

type Filetype interface {
	isFiletype()
	GetKind() Filekind
	io.WriterTo
	GetEncodedSizeBytes() int
}

func ReadFiletype(r io.Reader) (m Filetype, nTotal int64, err error) {
	var nField int64
	var discriminant Filekind
	{
		var m Filekind
		*(*int32)(&m), nField, err = runtime.ReadInt(r)
		nTotal += nField
		if err != nil {
			goto done
		}
		discriminant = m
	}
	switch discriminant {
	case 0:
		var mArm Filetype_TEXT
		{
			m := &mArm
			_ = m
		}
		m = &mArm
	case 1:
		var mArm Filetype_DATA
		{
			m := &mArm
			{
				mSave := &m.Creator
				var m string
				m, nField, err = runtime.ReadASCIIString(r, 255)
				nTotal += nField
				if err != nil {
					goto done
				}
				*mSave = m
			}
		}
		m = &mArm
	case 2:
		var mArm Filetype_EXEC
		{
			m := &mArm
			{
				mSave := &m.Interpretor
				var m string
				m, nField, err = runtime.ReadASCIIString(r, 255)
				nTotal += nField
				if err != nil {
					goto done
				}
				*mSave = m
			}
		}
		m = &mArm
	default:
		err = fmt.Errorf("discriminant filetype.kind has unknown value %d", discriminant)
		goto done
	}
done:
	return
}

func readFiletypeKind(r io.Reader) (m Filekind, nTotal int64, err error) {
	var nField int64
	*(*int32)(&m), nField, err = runtime.ReadInt(r)
	nTotal += nField
	if err != nil {
		goto done
	}
done:
	return
}

func writeFiletypeKind(w io.Writer, m Filekind) (nTotal int64, err error) {
	var nField int64
	nField, err = runtime.WriteInt(w, int32(m))
	nTotal += nField
	if err != nil {
		goto done
	}
done:
	return
}

const filetypeKindEncodedSizeBytes = 4

type Filetype_TEXT struct{}

func (m *Filetype_TEXT) isFiletype() {}

func (m *Filetype_TEXT) GetKind() Filekind {
	return 0
}

func (m *Filetype_TEXT) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		var m Filekind = 0
		nField, err = runtime.WriteInt(w, int32(m))
		nTotal += nField
		if err != nil {
			goto done
		}
	}
done:
	return
}

func (m *Filetype_TEXT) GetEncodedSizeBytes() (nTotal int) {
	nTotal += 4
	return
}

type Filetype_DATA struct {
	Creator string
}

func (m *Filetype_DATA) isFiletype() {}

func (m *Filetype_DATA) GetKind() Filekind {
	return 1
}

func (m *Filetype_DATA) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		var m Filekind = 1
		nField, err = runtime.WriteInt(w, int32(m))
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := m.Creator
		nField, err = runtime.WriteASCIIString(w, 255, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
done:
	return
}

func (m *Filetype_DATA) GetEncodedSizeBytes() (nTotal int) {
	nTotal += 4
	{
		m := m.Creator
		nTotal += (len(m) + 7) &^ 3
	}
	return
}

type Filetype_EXEC struct {
	Interpretor string
}

func (m *Filetype_EXEC) isFiletype() {}

func (m *Filetype_EXEC) GetKind() Filekind {
	return 2
}

func (m *Filetype_EXEC) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		var m Filekind = 2
		nField, err = runtime.WriteInt(w, int32(m))
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := m.Interpretor
		nField, err = runtime.WriteASCIIString(w, 255, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
done:
	return
}

func (m *Filetype_EXEC) GetEncodedSizeBytes() (nTotal int) {
	nTotal += 4
	{
		m := m.Interpretor
		nTotal += (len(m) + 7) &^ 3
	}
	return
}

// Type definition "file".

type File struct {
	Filename string
	Type     Filetype
	Owner    string
	Data     []byte
}

func (m *File) ReadFrom(r io.Reader) (nTotal int64, err error) {
	var nField int64
	{
		mSave := &m.Filename
		var m string
		m, nField, err = runtime.ReadASCIIString(r, 255)
		nTotal += nField
		if err != nil {
			goto done
		}
		*mSave = m
	}
	{
		mSave := &m.Type
		var m Filetype
		m, nField, err = ReadFiletype(r)
		nTotal += nField
		if err != nil {
			goto done
		}
		*mSave = m
	}
	{
		mSave := &m.Owner
		var m string
		m, nField, err = runtime.ReadASCIIString(r, 32)
		nTotal += nField
		if err != nil {
			goto done
		}
		*mSave = m
	}
	{
		mSave := &m.Data
		var m []byte
		m, nField, err = runtime.ReadVariableLengthOpaque(r, 65535)
		nTotal += nField
		if err != nil {
			goto done
		}
		*mSave = m
	}
done:
	return
}

func (m *File) WriteTo(w io.Writer) (nTotal int64, err error) {
	var nField int64
	{
		m := m.Filename
		nField, err = runtime.WriteASCIIString(w, 255, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := m.Type
		nField, err = m.WriteTo(w)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := m.Owner
		nField, err = runtime.WriteASCIIString(w, 32, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
	{
		m := m.Data
		nField, err = runtime.WriteVariableLengthOpaque(w, 65535, m)
		nTotal += nField
		if err != nil {
			goto done
		}
	}
done:
	return
}

func (m *File) GetEncodedSizeBytes() (nTotal int) {
	{
		m := m.Filename
		nTotal += (len(m) + 7) &^ 3
	}
	{
		m := m.Type
		nTotal += m.GetEncodedSizeBytes()
	}
	{
		m := m.Owner
		nTotal += (len(m) + 7) &^ 3
	}
	{
		m := m.Data
		nTotal += (len(m) + 7) &^ 3
	}
	return
}
